#;
(define (multiple-dwelling)
  (let ((floors '(1 2 3 4 5)))
    (let-cells (baker cooper fletcher miller smith
                      b=5 c=1 f=5 f=1 m>c sf fc one five
                      s-f as-f f-c af-c)
               (one-of floors baker)       (one-of floors cooper)
               (one-of floors fletcher)    (one-of floors miller)
               (one-of floors smith)
               (require-distinct
                 (list baker cooper fletcher miller smith))
               ((constant 1) one)        ((constant 5) five)
               (=? five baker b=5)       (forbid b=5)
               (=? one cooper c=1)       (forbid c=1)
               (=? five fletcher f=5)    (forbid f=5)
               (=? one fletcher f=1)     (forbid f=1)
               (>? miller cooper m>c)    (require m>c)
               (subtractor smith fletcher s-f)
               (absolute-value s-f as-f)
               (=? one as-f sf)          (forbid sf)
               (subtractor fletcher cooper f-c)
               (absolute-value f-c af-c)
               (=? one af-c fc)          (forbid fc)
               (list baker cooper fletcher miller smith))))

(define (all-except-deducer exceptions accumulator)
  (lambda ()
    (add-content accumulator
                 (lset-difference equal?
                                  (accumulator-content accumulator)
                                  exceptions))))

(define (greater-than-deducer accum1 accum2)
  (lambda ()
    (or (null? (accumulator-content accum1))
        (null? (accumulator-content accum2))
        (let ((accum1-max
                (apply max (accumulator-content accum1)))
              (accum2-min
                (apply min (accumulator-content accum2))))
          (add-content accum1
                       (filter (lambda (elt)
                                 (> elt accum2-min))
                               (accumulator-content accum1)))
          (add-content accum2
                       (filter (lambda (elt)
                                 (< elt accum1-max))
                               (accumulator-content accum2)))))))

(define (not-adjacent-deducer accum1 accum2)
  (define (values-ok? val1 val2)
    (not (<= (abs (- val1 val2)) 1)))
  (lambda ()
    (add-content accum1
                 (filter (lambda (elt1)
                           (any (lambda (elt2)
                                  (values-ok? elt1 elt2))
                                (accumulator-content accum2)))
                         (accumulator-content accum1)))
    (add-content accum2
                 (filter (lambda (elt2)
                           (any (lambda (elt1)
                                  (values-ok? elt1 elt2))
                                (accumulator-content accum1)))
                         (accumulator-content accum2)))))

(define (multiple-dwelling)
  (let ((baker    (possibilities-accumulator '(1 2 3 4 5)))
        (cooper   (possibilities-accumulator '(1 2 3 4 5)))
        (fletcher (possibilities-accumulator '(1 2 3 4 5)))
        (miller   (possibilities-accumulator '(1 2 3 4 5)))
        (smith    (possibilities-accumulator '(1 2 3 4 5))))
    (let ((fellas (list baker cooper fletcher miller smith))
          (make-drivees
            (lambda (fellas)
              (let ((baker (car fellas))
                    (cooper (cadr fellas))
                    (fletcher (caddr fellas))
                    (miller (cadddr fellas))
                    (smith (car (cddddr fellas))))
                (list (all-different-deducer fellas)
                      (all-except-deducer '(5) baker)
                      (all-except-deducer '(1) cooper)
                      (all-except-deducer '(1 5) fletcher)
                      (greater-than-deducer miller cooper)
                      (not-adjacent-deducer smith fletcher)
                      (not-adjacent-deducer fletcher cooper))))))
      #;(one-guess-drive fellas make-drivees)
      (drive fellas (make-drivees fellas))
      fellas)))
